numpy 入门篇
##################################################################################

什么是 numpy
**********************************************************************************

为什么要学习 numpy
==================================================================================

	| 快速
	| 方便
	| 科学计算的基础库

numpy 是什么
==================================================================================

一个在 Python 中做科学计算的基础库，重在数值计算，也是大部分 PYTHON 科学计算库的基础库，多用于在大型、多维数组上执行数值运算。

numpy 基础
**********************************************************************************

numpy 创建数组(矩阵)
==================================================================================

.. code-block:: python

	# 创建数组
	import numpy as np

	a = np.array([1,2,3,4,5])
	b = np.array(range(1,6))
	c = np.arange(1,6)
	print(a)
	print(b)
	print(c)

	# [1 2 3 4 5]
	# [1 2 3 4 5]
	# [1 2 3 4 5]

	# 上面 a,b,c, 内容相同, 注意 arange 和 range 的区别

	# 数组的类名
	a = np.array([1,2,3,4,5])
	type(a)
	# ---> numpy.ndarray

	# 数据的类型
	print(a.dtype)
	# ---> int64

numpy 中常见的更多数据类型
==================================================================================

	| 类型 类型代码 说明
	| int8、uint8 i1、u1 有符号和无符号8位整型（1字节）
	| int16、uint16 i2、u2 有符号和无符号16位整型（2字节）
	| int32、uint32 i4、u4 有符号和无符号32位整型（4字节）
	| int64、uint64 i8、u8 有符号和无符号64位整型（8字节）
	| float16 f2 半精度浮点数
	| float32 f4、f 单精度浮点数
	| float64 f8、d 双精度浮点数
	| float128 f16、g 扩展精度浮点数
	| complex64 c8 分别用两个32位表示的复数
	| complex128 c16 分别用两个64位表示的复数
	| complex256 c32 分别用两个128位表示的复数
	| bool b 布尔型
	| object O python对象
	| string Sn 固定长度字符串，每个字符1字节，如S10
	| unicode Un 固定长度Unicode，字节数由系统决定，如U10

数据类型的操作
==================================================================================

.. code-block:: python

	# 指定创建的数组的数据类型
	a = np.array([1,0,1,0],dtype=bool) # 或者使用 dtype='?'
	print(a)

	# ---> [ True False  True False]

	# 指定创建的数组的数据类型
	a = np.array([1,0,1,0],dtype=bool) # 或者使用 dtype='?'
	print(a)
	# ---> [ True False  True False]

	# 修改数组的数据类型
	b = a.astype("i1")
	print(b)
	# --> [1 0 1 0]

	# 或者使用 a.asType(np.int8)
	c = a.astype(np.int8)
	print(c)
	# --> [1 0 1 0]

	# 修改浮点型的小数位数
	#numpy中的小数
	t7 = np.array([random.random() for i in range(10)])
	print(t7)
	print(t7.dtype)

	t8 = np.round(t7,2)
	print(t8)

	# [0.23509756 0.18365565 0.42878215 0.17844451 0.28498626 0.03637158
	#  0.81981437 0.51776255 0.74482902 0.91590774]
	# float64
	# [0.24 0.18 0.43 0.18 0.28 0.04 0.82 0.52 0.74 0.92] 

.. tip::

	综合案例

	.. code-block:: python

		# coding=utf-8
		import numpy as np
		import random

		#使用numpy生成数组,得到ndarray的类型
		t1 = np.array([1,2,3,])
		print(t1)
		print(type(t1))

		t2 = np.array(range(10))
		print(t2)
		print(type(t2))

		t3 = np.arange(4,10,2)
		print(t3)
		print(type(t3))

		print(t3.dtype)
		print("*"*100)
		#numpy中的数据类型

		t4 = np.array(range(1,4),dtype="i1")
		print(t4)
		print(t4.dtype)

		##numpy中的bool类型
		t5 = np.array([1,1,0,1,0,0],dtype=bool)
		print(t5)
		print(t5.dtype)

		#调整数据类型
		t6 = t5.astype("int8")
		print(t6)
		print(t6.dtype)

		#numpy中的小数
		t7 = np.array([random.random() for i in range(10)])
		print(t7)
		print(t7.dtype)

		t8 = np.round(t7,2)
		print(t8)

数组的形状
==================================================================================

.. code-block:: python

	a = np.array([[3,4,5,6,7,8],[4,5,6,7,8,9]])
	print(a)
	# [[3 4 5 6 7 8]
	#  [4 5 6 7 8 9]]

	# 查看数组的形状
	print(a.shape)
	# (2, 6)

	# 修改数组的形状
	print(a.reshape(3,4))
	# [[3 4 5 6]
	#  [7 8 4 5]
	#  [6 7 8 9]]

	print(a.shape)
	# (2, 6) a 的形状没有改变

	b = a.reshape(3,4)
	print(b.shape)
	# (3, 4)
	print(b)
	# [[3 4 5 6]
	#  [7 8 4 5]
	#  [6 7 8 9]]

	# 把数组转化为 1 维度数据
	c = b.reshape(1,12)
	print(c)
	# [[3 4 5 6 7 8 4 5 6 7 8 9]]  # 这是一维度数组吗？

	print(b.flatten())
	# [3 4 5 6 7 8 4 5 6 7 8 9]

数组和数的计算
==================================================================================

.. code-block:: python

	a = np.array([[3,4,5,6,7,8],[4,5,6,7,8,9]])
	print(a)
	# [[3 4 5 6 7 8]
	#  [4 5 6 7 8 9]]

	print(a+1)
	# [[ 4  5  6  7  8  9]
	#  [ 5  6  7  8  9 10]]

	print(a*3)
	# [[ 9 12 15 18 21 24]
	#  [12 15 18 21 24 27]]

	# 这是一-个numpy的广播机制造成的,在运算过程中,加减乘除的值被广播到所有的元素上面

数组和数组的计算
==================================================================================

.. code-block:: python

	a = np.array([[3,4,5,6,7,8],[4,5,6,7,8,9]])
	print(a)
	# [[3 4 5 6 7 8]
	#  [4 5 6 7 8 9]]

	b = np.array([[21,22,23,24,25,26],[27,28,29,30,31,32]])
	print(b)
	# [[21 22 23 24 25 26]
	#  [27 28 29 30 31 32]]

	# 数组和数组的加减法
	print(a+b)
	# [[24 26 28 30 32 34]
	#  [31 33 35 37 39 41]]

	# 数组和数组的乘除法
	print(a*b)
	# [[ 63  88 115 144 175 208]
	#  [108 140 174 210 248 288]]

	c = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
	print(c)
	# [[ 1  2  3  4]
	#  [ 5  6  7  8]
	#  [ 9 10 11 12]]

	print(a*c)
	# operands could not be broadcast together with shapes (2,6) (3,4)

	a = np.array([[3,4,5,6,7,8],[4,5,6,7,8,9]])
	print(a)
	# [[3 4 5 6 7 8]
	#  [4 5 6 7 8 9]]

	c = np.array([1,2,3,4,5,6])
	print(a-c)
	# [[2 2 2 2 2 2]
	#  [3 3 3 3 3 3]]

	print(a*c)
	# [[ 3  8 15 24 35 48]
	#  [ 4 10 18 28 40 54]]

	c = np.array([[1],[2]])
	print(c)
	# [[1]
	#  [2]]

	print(c+a)
	# [[ 4  5  6  7  8  9]
	#  [ 6  7  8  9 10 11]]

	print(a*c)
	# [[ 3  4  5  6  7  8]
	#  [ 8 10 12 14 16 18]]

	print(c*a)
	# [[ 3  4  5  6  7  8]
	#  [ 8 10 12 14 16 18]]

* 广播原则

如果两个数组的后缘维度(trailing dimension，即从末尾开始算起的维度]的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会在缺失和(或)长度为1的维度上进行。

	| 怎么理解呢? 

		| 可以把维度指的是shape所对应的数字个数

	| 那么问题来了:

		| shape为(3,3,3)的数组能够和(3,2)的数组进行计算么?
		| shape为(3,3,2)的数组能够和(3,2)的数组进行计算么?

	| 有什么好处呢?

		| 举个例子:每列的数据减去列的平均值的结果

轴 (axis)
==================================================================================

在 numpy 中可以理解为方向,使用 0,1,2... 数字表示,对于一个一维数组,只有一个0轴,对于 2 维数组(shape(2,2)),有 0 轴和 1 轴,对于三维数组(shape(2,2, 3)),有 0,1,2 轴

有了轴的概念之后,我们计算会更加方便,比如计算一个 2 维数组的平均值,必须指定是计算哪个方向上面的数字的平均值

那么问题来了:

	| 在前面的知识,轴在哪里?
	| 回顾 np.arange(0,10).reshape((2,5)),reshpe中 2 表示 0 轴长度(包含数据的条数)为 2, 1 轴长度为 5, 2X5 一共 10 个数据

* 二维数组的轴

.. figure:: image/axis_001.webp
   :alt: axis_001.webp

* 三维数组的轴

.. figure:: image/axis_002.webp
   :alt: axis_002.webp

numpy 常用方法
**********************************************************************************

numpy 读取数据
==================================================================================

	| CSV:Comma-Separated Value,逗号分隔值文件
	| 显示：表格状态
	| 源文件：换行和逗号分隔行列的格式化文本,每一行的数据表示一条记录

由于 csv 便于展示,读取和写入,所以很多地方也是用 csv 的格式存储和传输中小型的数据, 会经常操作 csv 格式的文件,但是操作数据库中的数据也是很容易的实现的

	| np.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)

参数说明

	| 参数         解释
	| frame       文件、字符串或产生器，可以是.gz或bz2压缩文件
	| dtype       数据类型，可选，CSV的字符串以什么数据类型读入数组中，默认np. float
	| delimiter   分隔字符串，默认是任何空格,改为逗号
	| skiprows    跳过前x行，- -般跳过第-行表头
	| usecols     读取指定的列，索引，元组类型。.
	| unpack      如果True,读入属性将分别写入不同数组变量，False 读入数据只写入一个数. 组变量，默认False

读取和存储数据
==================================================================================

现在这里有一个英国和美国各自youtube1000多个视频的点击,喜欢,不喜欢,评论数量(["views","likes","dislikes","comment_total"])的csv,运用刚刚所学习的只是,我们尝试来对其进行操作

数据来源: ``https://www.kaggle.com/datasnaek/youtube/data``

	| np.loadtxt(US_video_data_numbers_path,delimiter=",",dtype=int,unpack=1)

注意其中添加 delimiter 和 dtype 以及 unpack 的效果

	| delimiter :指定边界符号是什么，不指定会导致每行数据为一个整体的字符串而报错
	| dtype :默认情况下对于较大的数据会将其变为科学计数的方式
	| upack :默认是Flase(0),默认情况下，有多少条数据,就会有多少行为True(1)的情况下,每-列的数据会组成-行,原始数据有多少列,加载出来的数据就会有多少行,相当于转置的效果

* 结合之前的所学的 matplotlib 把英国和美国的数据呈现出来

.. code-block:: python

	us_file_path = "./youtube_video_data/US_video_data_numbers.csv"
	uk_file_path = "./youtube_video_data/GB_video_data_numbers.csv"

	# t1 = np.loadtxt(us_file_path,delimiter=",",dtype="int",unpack=True)
	t2 = np.loadtxt(us_file_path,delimiter=",",dtype="int")

	# print(t1)
	print(t2)

转置
==================================================================================

转置是一种变换,对于 numpy 中的数组来说,就是在对角线方向交换数据,目的也是为了更方便的去处理数据

.. code-block:: python

	t = np.array([[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17]])
	print(t)
	# [[ 0  1  2  3  4  5]
	#  [ 6  7  8  9 10 11]
	#  [12 13 14 15 16 17]]

	t1 = t.transpose()
	print(t1)
	# [[ 0  6 12]
	#  [ 1  7 13]
	#  [ 2  8 14]
	#  [ 3  9 15]
	#  [ 4 10 16]
	#  [ 5 11 17]]

	t2 = t.swapaxes(1,0)
	print(t2)
	# [[ 0  6 12]
	#  [ 1  7 13]
	#  [ 2  8 14]
	#  [ 3  9 15]
	#  [ 4 10 16]
	#  [ 5 11 17]]

	t3 = t.T
	print(t3)
	# [[ 0  6 12]
	#  [ 1  7 13]
	#  [ 2  8 14]
	#  [ 3  9 15]
	#  [ 4 10 16]
	#  [ 5 11 17]]

以上的三种方法都可以实现二维数组的转置的效果,转置和交换轴的效果一样

索引和切片
==================================================================================

对于刚刚加载出来的数据,我如果只想选择其中的某一列(行), 应该怎么做呢? 其实操作很简单,和 python 中列表的操作一样

.. code-block:: python

	import numpy as np

	a = np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11]])
	print(a)
	# [[ 0  1  2  3]
	#  [ 4  5  6  7]
	#  [ 8  9 10 11]]

	print(a[1]) # 取一行
	# [4 5 6 7]

	print(a[:,2]) # 取一列
	# [ 2  6 10]

	print(a[1:3]) # 取多行
	# [[ 4  5  6  7]
	#  [ 8  9 10 11]]

	print(a[:, 2:4]) # 取多列
	# [[ 2  3]
	#  [ 6  7]
	#  [10 11]]

	print(a[[1,2],:])
	# [[ 4  5  6  7]
	#  [ 8  9 10 11]]

	print(a[:,[2,3]])
	# [[ 2  3]
	#  [ 6  7]
	#  [10 11]]

* 综合案例

.. code-block:: python

	# coding=utf-8
	import numpy as np

	us_file_path = "./youtube_video_data/US_video_data_numbers.csv"
	uk_file_path = "./youtube_video_data/GB_video_data_numbers.csv"

	# t1 = np.loadtxt(us_file_path,delimiter=",",dtype="int",unpack=True)
	t2 = np.loadtxt(us_file_path,delimiter=",",dtype="int")

	# print(t1)
	print(t2)

	print("*"*100)

	#取行
	# print(t2[2])

	#取连续的多行
	# print(t2[2:])

	#取不连续的多行
	# print(t2[[2,8,10]])

	# print(t2[1,:])
	# print(t2[2:,:])
	# print(t2[[2,10,3],:])

	#取列
	# print(t2[:,0])

	#取连续的多列
	# print(t2[:,2:])

	#取不连续的多列
	# print(t2[:,[0,2]])

	#去行和列，取第3行，第四列的值
	# a = t2[2,3]
	# print(a)
	# print(type(a))

	#取多行和多列，取第3行到第五行，第2列到第4列的结果
	#去的是行和列交叉点的位置
	b = t2[2:5,1:4]
	# print(b)

	#取多个不相邻的点
	#选出来的结果是（0，0） （2，1） （2，3）
	c = t2[[0,2,2],[0,1,3]]
	print(c)

数值的修改
==================================================================================

.. code-block:: python

	import numpy as np

	t = np.array([[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,21,22,23]])
	print(t)
	# [[ 0  1  2  3  4  5]
	#  [ 6  7  8  9 10 11]
	#  [12 13 14 15 16 17]
	#  [18 19 20 21 22 23]]

	print(t[:, 2:4])
	# [[ 2  3]
	#  [ 8  9]
	#  [14 15]
	#  [20 21]]

	t[:,2:4] = 0
	print(t)
	# [[ 0  1  0  0  4  5]
	#  [ 6  7  0  0 10 11]
	#  [12 13  0  0 16 17]
	#  [18 19  0  0 22 23]]

修改行列的值，很容易的实现，但是如果条件更复杂呢？比如想要把t中小于 10 的数字替换为 3

布尔索引
==================================================================================

.. code-block:: python

	import numpy as np

	t = np.arange(24).reshape((4, 6))
	t1 = t < 10
	print(t1)
	# [[ True  True  True  True  True  True]
	#  [ True  True  True  True False False]
	#  [False False False False False False]
	#  [False False False False False False]]

	t[t < 10] = 0
	print(t)

把 t 中小于 10 的数字替换为 0，把大于 10 的替换为 10，应该怎么做？？

三元运算符
==================================================================================

.. code-block:: python

	import numpy as np

	t = np.arange(24).reshape((4, 6))
	print(t)
	# [[ 0  1  2  3  4  5]
	#  [ 6  7  8  9 10 11]
	#  [12 13 14 15 16 17]
	#  [18 19 20 21 22 23]]

	t1 = np.where(t < 10, 0, 10)
	print(t1)
	# [[ 0  0  0  0  0  0]
	#  [ 0  0  0  0 10 10]
	#  [10 10 10 10 10 10]
	#  [10 10 10 10 10 10]]

clip(裁剪)
==================================================================================

.. code-block:: python

	import numpy as np

	t = np.array([[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,np.nan,np.nan,np.nan]])
	print(t)
	# [[ 0.  1.  2.  3.  4.  5.]
	#  [ 6.  7.  8.  9. 10. 11.]
	#  [12. 13. 14. 15. 16. 17.]
	#  [18. 19. 20. nan nan nan]]

	t1 = t.clip(10,18)
	print(t1)
	# [[10. 10. 10. 10. 10. 10.]
	#  [10. 10. 10. 10. 10. 11.]
	#  [12. 13. 14. 15. 16. 17.]
	#  [18. 18. 18. nan nan nan]]

小于 10 的替换为 10，大于 18 的替换为了 18，但是 nan 没有被替换，那么 nan 是什么？

nan 和 inf
==================================================================================

nan(NAN,Nan):not a number表示不是一个数字

什么时候 numpy 中会出现nan：

	| 当我们读取本地的文件为 float 的时候，如果有缺失，就会出现 nan
	| 当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)

inf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷

什么时候回出现inf包括（-inf，+inf）

	| 比如一个数字除以0,（python 中直接会报错，numpy 中是一个 inf 或者 -inf）

那么如何指定一个 nan 或者 inf 呢？注意他们的 type 类型

.. code-block:: python

	a = np.nan
	print(type(a))
	# <class 'float'>

	a = np.inf
	print(type(a))
	# <class 'float'>

nan 的注意点
==================================================================================

	| 1.两个nan是不相等的
	| 2.np.nan!=np.nan
	| 3.利用以上的特性，判断数组中nan的个数
	| 4.由于2，那么如何判断一个数字是否为 nan 呢? 通过np.isnan(a)来判断，返回 bool 类型比如希望把nan替换为0
	| 5.nan 和任何值计算都为 nan

.. code-block:: python

	np.nan == np.nan
	# False

	np.nan != np.nan
	# True

	t = np.array([1,2,np.nan])
	print(t)
	# [ 1.  2. nan]
	np.count_nonzero(t!=t)
	# 1

	t[np.isnan(t)]=0
	print(t)
	# [1. 2. 0.]

.. tip::

	| 那么问题来了，在一组数据中单纯的把nan替换为0，合适么？会带来什么样的影响？比如，全部替换为0后，替换之前的平均值如果大于0，替换之后的均值肯定会变小，所以更一般的方式是把缺失的数值替换为均值（中值）或者是直接删除有缺失值的一行
	| 
	| 那么问题来了：
	|       如何计算一组数据的中值或者是均值
	|       如何删除有缺失数据的那一行（列）[在pandas中介绍]

numpy 常用统计方法
**********************************************************************************

	| 求和：t.sum(axis=None)
	| 均值：t.mean(a,axis=None)  受离群点的影响较大
	| 中值：np.median(t,axis=None) 
	| 最大值：t.max(axis=None) 
	| 最小值：t.min(axis=None)
	| 极值：np.ptp(t,axis=None) 即最大值和最小值只差
	| 标准差：t.std(axis=None) 
	| 
	| 标准差是一组数据平均值分散程度的一种度量。一个较大的标准差，代表大部分数值和其平均值之间差异较大；一个较小的标准差，代表这些数值较接近平均值
	| 反映出数据的波动稳定情况，越大表示波动越大，约不稳定
	| 
	| 默认返回多维数组的全部的统计结果,如果指定 axis 则返回一个当前轴上的结果

ndarry 缺失值填充均值
**********************************************************************************

t 中存在 nan 值，如何操作把其中的 nan 填充为每一列的均值

	| t = array([[  0.,   1.,   2.,   3.,   4.,   5.],
	|        [  6.,   7.,  nan,   9.,  10.,  11.],
	|        [ 12.,  13.,  14.,  nan,  16.,  17.],
	|        [ 18.,  19.,  20.,  21.,  22.,  23.]])

.. code-block:: python

	def fill_nan_by_column_mean(t):
	    for i in range(t.shape[1]):
	        nan_num = np.count_nonzero(t[:, i][t[:, i] != t[:, i]])  #计算非nan的个数
	        if nan_num > 0:  #存在nan值
	            now_col = t[:, i]
	            now_col_not_nan = now_col[np.isnan(now_col) == False].sum()
	            now_col_mean = now_col_not_nan / (t.shape[0] - nan_num)  #和/个数
	            now_col[np.isnan(now_col)] = now_col_mean  #赋值给now_.col
	            t[:, i] = now_col  #赋值给t，即更新t的当前列

麻烦么？别担心，学完pandas有更容易的方法处理缺失值

数组的拼接
**********************************************************************************

现在希望把之前案例中两个国家的数据方法一起来研究分析，那么应该怎么做？

.. code-block:: python

	t1 = np.array([[0,1,2,3,4,5],[6,7,8,9,10,11]])
	print(t1)
	# [[ 0  1  2  3  4  5]
	#  [ 6  7  8  9 10 11]]
	t2 = np.array([[12,13,14,15,16,17],[18,19,20,21,22,23]])
	print(t2)
	# [[12 13 14 15 16 17]
	#  [18 19 20 21 22 23]]
	t3 = np.vstack((t1,t2)) # 竖直拼接
	print(t3)
	# [[ 0  1  2  3  4  5]
	#  [ 6  7  8  9 10 11]
	#  [12 13 14 15 16 17]
	#  [18 19 20 21 22 23]]
	t4 = np.hstack((t1,t2)) # 水平拼接
	print(t4)
	# [[ 0  1  2  3  4  5 12 13 14 15 16 17]
	#  [ 6  7  8  9 10 11 18 19 20 21 22 23]]

数组的行列交换
**********************************************************************************

数组水平或者竖直拼接很简单，但是拼接之前应该注意什么？竖直拼接的时候：每一列代表的意义相同！！！否则牛头不对马嘴

如果每一列的意义不同，这个时候应该交换某一组的数的列，让其和另外一类相同。如何交换某个数组的行或者列呢？

.. code-block:: python

	t = np.arange(12,24).reshape(3,4)
	print(t)
	# [[12 13 14 15]
	#  [16 17 18 19]
	#  [20 21 22 23]]

	t[[1,2],:] = t[[2,1],:] # 行交换
	print(t)
	# [[12 13 14 15]
	#  [20 21 22 23]
	#  [16 17 18 19]]

	t[:,[1,2]] = t[:,[2,1]] # 列交换
	print(t)
	# [[12 14 13 15]
	#  [20 22 21 23]
	#  [16 18 17 19]]

更多好用的方法
**********************************************************************************

	| 获取最大值最小值的位置

		| np.argmax(t,axis=0)
		| np.argmin(t,axis=1)

	| 创建一个全0的数组: np.zeros((3,4))
	| 创建一个全1的数组: np.ones((3,4))
	| 创建一个对角线为1的正方形数组(方阵)：np.eye(3)

生成随机数
**********************************************************************************

	| 参数                解释
	| .rand(d0,d1,..dn)  创建d0-dn维度的均匀分布的随机数数组，浮点数，范围从0-1
	| .randn(d0,d1,..dn) 创建d0-dn维度的标准正态分布随机数，浮点数，平均数0，标准差1
	| .randint(low,high,(shape))  从给定上下限范围选取随机数整数，范围是low,high，形状是shape
	| .uniform(low,high,(size))   产生具有均匀分布的数组，low起始值， high结束值， size形状
	| .normal(loc,scale,(size))   从指定正态分布中随机抽取样本，分布中心是loc (概率分布的均值) ,标准差是scale，形状是size
	| .seed(s)            随机数种子，s是给定的种子值。因为计算机生成的是伪随机数，所以通过设定相同的随机数种子，可以每次生成相同的随机数

注意点 copy 和 view
**********************************************************************************

	| a=b 完全不复制，a 和 b 相互影响
	| a = b[:],视图的操作，一种切片，会创建新的对象 a，但是 a 的数据完全由 b 保管，他们两个的数据变化是一致的，
	| a = b.copy(),复制，a和b互不影响 

其他资料
**********************************************************************************

	| github 地址: DataAnalysis
	| `Python 之 Numpy 详细教程 <https://blog.csdn.net/a373595475/article/details/79580734?ops_request_misc=&request_id=&biz_id=102&utm_term=numpy&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-79580734>`_
























































































































